<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000000">
    <title>Perlin Terrain</title>
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon.png">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; }
        canvas { display: block; }
        #permissionButton {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1000;
            display: none;
        }
        #permissionButton:hover {
            background-color: #0056b3;
        }
        #errorMessage {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: red;
            font-size: 16px;
            z-index: 1000;
            text-align: center;
        }
        @media (orientation: landscape) {
            body { transform: rotate(0deg); }
        }
        @media (orientation: portrait) {
            body { transform: rotate(0deg); }
        }
    </style>
</head>
<body>
    <button id="permissionButton">Enable Tilt Controls</button>
    <div id="errorMessage"></div>
    <script>
        // Load scripts with error handling
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = () => reject(new Error(`Failed to load script: ${src}`));
                document.head.appendChild(script);
            });
        }

        // Check WebGL availability
        function isWebGLAvailable() {
            try {
                const canvas = document.createElement('canvas');
                return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
            } catch (e) {
                return false;
            }
        }

        async function init() {
            try {
                if (!isWebGLAvailable()) {
                    throw new Error('WebGL is not supported in this browser');
                }

                await Promise.all([
                    loadScript('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js'),
                    loadScript('https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js')
                ]);

                // Lock orientation to portrait
                if (screen.orientation && screen.orientation.lock) {
                    try {
                        await screen.orientation.lock('portrait');
                        console.log('Orientation locked to portrait');
                    } catch (error) {
                        console.warn('Orientation lock failed:', error);
                    }
                }

                // Scene setup
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setClearColor(0x000000, 1);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(renderer.domElement);

                // Fallback plane
                const fallbackGeometry = new THREE.PlaneGeometry(50, 50);
                const fallbackMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const fallbackPlane = new THREE.Mesh(fallbackGeometry, fallbackMaterial);
                fallbackPlane.position.set(0, 0, 0);
                scene.add(fallbackPlane);

                // Terrain generation
                const width = 100;
                const height = 100;
                const geometry = new THREE.PlaneGeometry(100, 100, width - 1, height - 1);
                const simplex = new SimplexNoise();
                const vertices = geometry.attributes.position.array;

                try {
                    for (let i = 0; i < vertices.length; i += 3) {
                        const x = vertices[i];
                        const y = vertices[i + 1];
                        vertices[i + 2] = simplex.noise2D(x * 0.05, y * 0.05) * 5;
                    }
                    geometry.attributes.position.needsUpdate = true;
                    geometry.computeVertexNormals();
                } catch (error) {
                    throw new Error('Failed to generate terrain: ' + error.message);
                }

                const material = new THREE.MeshStandardMaterial({ 
                    color: 0x888888, 
                    roughness: 0.7,
                    depthTest: true,
                    depthWrite: true
                });
                const terrain = new THREE.Mesh(geometry, material);
                terrain.rotation.x = 0;
                terrain.receiveShadow = true;
                terrain.castShadow = true;
                terrain.renderOrder = 1;
                console.log('Terrain added:', terrain.position);
                scene.add(terrain);

                // Marble creation
                const marbleRadius = 1;
                const marbleGeometry = new THREE.SphereGeometry(marbleRadius, 32, 32);
                const marbleMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x87CEEB, 
                    roughness: 0.5, 
                    metalness: 0.2,
                    depthTest: true,
                    depthWrite: true
                });
                const marble = new THREE.Mesh(marbleGeometry, marbleMaterial);
                marble.position.set(0, 0, 5);
                marble.castShadow = true;
                marble.receiveShadow = true;
                marble.renderOrder = 2;
                console.log('Marble added:', marble.position);
                scene.add(marble);

                // Debug sphere
                const debugSphereGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                const debugSphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const debugSphere = new THREE.Mesh(debugSphereGeometry, debugSphereMaterial);
                debugSphere.renderOrder = 3;
                console.log('Debug sphere added');
                scene.add(debugSphere);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(0, 50, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 1024;
                directionalLight.shadow.mapSize.height = 1024;
                directionalLight.shadow.camera.near = 10;
                directionalLight.shadow.camera.far = 100;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                console.log('Lights added');
                scene.add(directionalLight);

                // Camera position
                camera.position.set(0, 0, 75); // Moved back to ensure visibility
                camera.lookAt(0, 0, 0);
                console.log('Camera:', camera.position);

                // Mobile detection
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || ('ontouchstart' in window);

                // Device orientation for mobile
                let beta = 0, gamma = 0;
                let hasPermission = false;
                const permissionButton = document.getElementById('permissionButton');

                if (isMobile) {
                    permissionButton.style.display = 'block';
                    permissionButton.addEventListener('click', () => {
                        console.log('Requesting device orientation permission');
                        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                            DeviceOrientationEvent.requestPermission()
                                .then(permissionState => {
                                    console.log('Permission state:', permissionState);
                                    if (permissionState === 'granted') {
                                        hasPermission = true;
                                        permissionButton.style.display = 'none';
                                        window.addEventListener('deviceorientation', handleOrientation);
                                    } else {
                                        permissionButton.textContent = 'Permission Denied';
                                    }
                                })
                                .catch(error => {
                                    console.error('Permission error:', error);
                                    permissionButton.textContent = 'Permission Error';
                                });
                        } else {
                            hasPermission = true;
                            permissionButton.style.display = 'none';
                            window.addEventListener('deviceorientation', handleOrientation);
                        }
                    });

                    function handleOrientation(event) {
                        beta = event.beta ? event.beta * Math.PI / 180 : 0;
                        gamma = event.gamma ? event.gamma * Math.PI / 180 : 0;
                        console.log('Orientation:', { beta, gamma });
                    }
                } else {
                    permissionButton.style.display = 'none';
                }

                // Mouse drag for non-mobile
                let isDragging = false;
                let previousMouseX = 0, previousMouseY = 0;
                let phi = Math.PI / 4, theta = Math.PI / 4;

                if (!isMobile) {
                    document.addEventListener('mousedown', (event) => {
                        isDragging = true;
                        previousMouseX = event.clientX;
                        previousMouseY = event.clientY;
                    });

                    document.addEventListener('mousemove', (event) => {
                        if (isDragging) {
                            const deltaX = event.clientX - previousMouseX;
                            const deltaY = event.clientY - previousMouseY;
                            phi -= deltaX * 0.005;
                            theta = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, theta + deltaY * 0.005));
                            gamma = -deltaX * 0.01;
                            beta = -deltaY * 0.01;
                            previousMouseX = event.clientX;
                            previousMouseY = event.clientY;
                        }
                    });

                    document.addEventListener('mouseup', () => {
                        isDragging = false;
                    });
                }

                // Physics for marble
                let velocity = new THREE.Vector3(0, 0, 0);
                const gravity = 9.8;
                const friction = 0.98;
                const mass = 1;
                const dt = 1 / 60;

                function getTerrainHeight(x, y) {
                    const gridX = Math.max(0, Math.min(width - 1, (x + 50) / 100 * (width - 1)));
                    const gridY = Math.max(0, Math.min(height - 1, (y + 50) / 100 * (height - 1)));
                    const x0 = Math.floor(gridX);
                    const y0 = Math.floor(gridY);
                    const x1 = Math.min(x0 + 1, width - 1);
                    const y1 = Math.min(y0 + 1, height - 1);

                    const idx00 = (y0 * width + x0) * 3 + 2;
                    const idx10 = (y0 * width + x1) * 3 + 2;
                    const idx01 = (y1 * width + x0) * 3 + 2;
                    const idx11 = (y1 * width + x1) * 3 + 2;

                    const h00 = vertices[idx00] || 0;
                    const h10 = vertices[idx10] || 0;
                    const h01 = vertices[idx01] || 0;
                    const h11 = vertices[idx11] || 0;

                    const fx = gridX - x0;
                    const fy = gridY - y0;

                    const h0 = h00 * (1 - fx) + h10 * fx;
                    const h1 = h01 * (1 - fx) + h11 * fx;
                    const height = h0 * (1 - fy) + h1 * fy;
                    console.log('Terrain height at', { x, y }, ':', height);
                    return height;
                }

                function getTerrainSlope(x, y) {
                    const h = 0.1;
                    const height = getTerrainHeight(x, y);
                    const heightX = getTerrainHeight(x + h, y);
                    const heightY = getTerrainHeight(x, y + h);
                    const slopeX = (heightX - height) / h;
                    const slopeY = (heightY - height) / h;
                    return new THREE.Vector3(-slopeX, -slopeY, 0);
                }

                // Animation loop
                let time = 0;
                let lastPosition = marble.position.clone();
                function animate() {
                    requestAnimationFrame(animate);

                    // Update terrain
                    try {
                        for (let i = 0; i < vertices.length; i += 3) {
                            const x = vertices[i];
                            const y = vertices[i + 1];
                            vertices[i + 2] = simplex.noise3D(x * 0.05, y * 0.05, time * 0.1) * 5;
                        }
                        geometry.attributes.position.needsUpdate = true;
                        geometry.computeVertexNormals();
                    } catch (error) {
                        console.error('Terrain update error:', error);
                    }
                    time += 0.01;

                    // Update marble physics
                    const terrainHeight = getTerrainHeight(marble.position.x, marble.position.y);
                    debugSphere.position.set(marble.position.x, marble.position.y, terrainHeight);
                    marble.position.z = terrainHeight + marbleRadius + 0.5; // Increased offset

                    const slope = getTerrainSlope(marble.position.x, marble.position.y);
                    let acceleration = new THREE.Vector3(slope.x * gravity, slope.y * gravity, 0);
                    acceleration.x += Math.sin(gamma) * gravity;
                    acceleration.y -= Math.sin(beta) * gravity;
                    console.log('Acceleration:', { terrain: slope, tilt: { x: Math.sin(gamma), y: -Math.sin(beta) } });
                    velocity.add(acceleration.multiplyScalar(dt / mass));
                    velocity.multiplyScalar(friction);
                    marble.position.add(velocity.clone().multiplyScalar(dt));

                    // Boundary check
                    marble.position.x = Math.max(-49, Math.min(49, marble.position.x));
                    marble.position.y = Math.max(-49, Math.min(49, marble.position.y));

                    // Debug height
                    if (marble.position.z < terrainHeight) {
                        console.warn(`Marble below surface: z=${marble.position.z}, terrainHeight=${terrainHeight}`);
                        marble.position.z = terrainHeight + marbleRadius + 0.5;
                    }
                    console.log('Marble position:', { x: marble.position.x, y: marble.position.y, z: marble.position.z });

                    // Simulate rolling
                    const displacement = marble.position.clone().sub(lastPosition);
                    const distance = displacement.length();
                    if (distance > 0) {
                        const axis =
